name: C/C++ Build (Ubuntu)

on:
  workflow_call:

jobs:
  build:
    name: Ubuntu Build
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Install basic build tools
      run: |
        sudo apt-get update
        sudo apt-get install -y build-essential cmake ninja-build pkg-config

    - name: Auto-detect and install dependencies
      run: |
        # If a dependencies.txt file exists, use it to install dependencies
        if [ -f "dependencies.txt" ]; then
          sudo apt-get install -y $(cat dependencies.txt)
        fi
        
        # If there's a CMake file, extract and install dependencies
        if [ -f "CMakeLists.txt" ]; then
          # Extract package dependencies from CMake files
          CMAKE_DEPS=$(grep -E "find_package|pkg_check_modules" CMakeLists.txt | grep -oE '[A-Za-z0-9_-]+' | sort | uniq)
          if [ ! -z "$CMAKE_DEPS" ]; then
            echo "Detected CMake dependencies: $CMAKE_DEPS"
            # Try to install common mappings from CMake module names to apt package names
            for DEP in $CMAKE_DEPS; do
              case $DEP in
                Boost)
                  sudo apt-get install -y libboost-all-dev
                  ;;
                ZLIB)
                  sudo apt-get install -y zlib1g-dev
                  ;;
                OpenSSL)
                  sudo apt-get install -y libssl-dev
                  ;;
                Threads)
                  # Usually built-in
                  ;;
                Qt5|Qt6)
                  sudo apt-get install -y qtbase5-dev
                  ;;
                CURL)
                  sudo apt-get install -y libcurl4-openssl-dev
                  ;;
                *)
                  # Try to guess package name (lowercase with lib prefix and -dev suffix)
                  GUESS_PKG="lib$(echo $DEP | tr '[:upper:]' '[:lower:]')-dev"
                  echo "Trying to install: $GUESS_PKG"
                  sudo apt-get install -y $GUESS_PKG || true
                  ;;
              esac
            done
          fi
        fi
        
        # If configure script exists, check for dependencies
        if [ -f "configure" ]; then
          # Run configure with --help to extract dependencies
          CONFIGURE_DEPS=$(./configure --help | grep -E 'with-[a-z0-9_-]+' | grep -oE 'with-[a-z0-9_-]+' | sed 's/with-//g')
          if [ ! -z "$CONFIGURE_DEPS" ]; then
            echo "Detected configure dependencies: $CONFIGURE_DEPS"
            # Try to install based on common naming patterns
            for DEP in $CONFIGURE_DEPS; do
              GUESS_PKG="lib$(echo $DEP | tr '[:upper:]' '[:lower:]')-dev"
              echo "Trying to install: $GUESS_PKG"
              sudo apt-get install -y $GUESS_PKG || true
            done
          fi
        fi
        
        # If vcpkg.json exists, extract dependencies
        if [ -f "vcpkg.json" ]; then
          VCPKG_DEPS=$(grep -Eo '"dependencies"[^]]*]' vcpkg.json | grep -Eo '"[^"]*"' | sed 's/"//g' | grep -v dependencies)
          if [ ! -z "$VCPKG_DEPS" ]; then
            echo "Detected vcpkg dependencies: $VCPKG_DEPS"
            # Try to map vcpkg package names to apt packages
            for DEP in $VCPKG_DEPS; do
              GUESS_PKG="lib$(echo $DEP | tr '[:upper:]' '[:lower:]')-dev"
              echo "Trying to install: $GUESS_PKG"
              sudo apt-get install -y $GUESS_PKG || true
            done
          fi
        fi
        
        # If conanfile.txt or conanfile.py exists, use Conan to handle dependencies
        if [ -f "conanfile.txt" ] || [ -f "conanfile.py" ]; then
          echo "Conan package manager detected, installing Conan..."
          pip install conan
          # Conan will handle the dependencies during the build step
        fi

    - name: Check build system
      id: check_build
      run: |
        # Check for different build systems and set outputs accordingly
        if [ -f "CMakeLists.txt" ]; then
          echo "HAS_CMAKE=true" >> $GITHUB_OUTPUT
        else
          echo "HAS_CMAKE=false" >> $GITHUB_OUTPUT
          echo "No CMakeLists.txt found in root directory. Will skip CMake build."
        fi
        
        if [ -f "configure" ] || [ -f "configure.ac" ] || [ -f "autogen.sh" ]; then
          echo "HAS_AUTOTOOLS=true" >> $GITHUB_OUTPUT
        else
          echo "HAS_AUTOTOOLS=false" >> $GITHUB_OUTPUT
        fi
        
        if [ -f "Makefile" ] || [ -f "makefile" ] || [ -f "GNUmakefile" ]; then
          echo "HAS_MAKEFILE=true" >> $GITHUB_OUTPUT
        else
          echo "HAS_MAKEFILE=false" >> $GITHUB_OUTPUT
        fi
        
        # Create build directory regardless of build system
        mkdir -p build

    - name: Configure and build with CMake
      if: steps.check_build.outputs.HAS_CMAKE == 'true'
      run: |
        cd build
        
        # If using Conan, install dependencies first
        if [ -f "../conanfile.txt" ] || [ -f "../conanfile.py" ]; then
          conan install .. --build=missing
        fi
        
        # Find CMakeLists.txt location (it might be in a subdirectory)
        CMAKE_DIR=".."
        if [ ! -f "../CMakeLists.txt" ]; then
          # Try to find the directory containing CMakeLists.txt
          CMAKE_DIR_FOUND=$(find .. -name "CMakeLists.txt" -not -path "*/build/*" -not -path "*/\.*" | head -n 1 | xargs dirname || echo "")
          if [ ! -z "$CMAKE_DIR_FOUND" ]; then
            CMAKE_DIR="$CMAKE_DIR_FOUND"
            echo "Found CMakeLists.txt in $CMAKE_DIR"
          fi
        fi
        
        # Attempt CMake configuration and build
        cmake "$CMAKE_DIR" -DCMAKE_BUILD_TYPE=Release -G Ninja || echo "CMake configuration failed, continuing anyway"
        cmake --build . --config Release || echo "CMake build failed, continuing anyway"
      continue-on-error: true

    - name: Build with Autotools
      if: steps.check_build.outputs.HAS_AUTOTOOLS == 'true'
      run: |
        # If autogen.sh exists, run it first
        if [ -f "autogen.sh" ]; then
          chmod +x autogen.sh
          ./autogen.sh || echo "autogen.sh failed, continuing anyway"
        fi
        
        # If configure.ac exists but no configure, run autoconf
        if [ -f "configure.ac" ] && [ ! -f "configure" ]; then
          autoreconf -i || echo "autoreconf failed, continuing anyway"
        fi
        
        # Check if this is a TensorFlow-like repo with an interactive configure script
        if [ -f "configure" ]; then
          # Check if this is TensorFlow or similar that needs non-interactive answers
          if grep -q "TensorFlow\|CUDA\|ROCm\|Python" configure; then
            echo "Detected TensorFlow-like configure script. Running in non-interactive mode..."
            # Create a response file for interactive prompts
            cat > /tmp/tf_responses << EOF
            

            
            
            n
            n
            Y
            
            
            n
            EOF
            # Run configure with automatic responses
            cat /tmp/tf_responses | ./configure || echo "configure failed, continuing anyway"
          else
            # Try running configure normally, but don't fail if it has problems
            chmod +x configure
            ./configure || echo "configure failed, continuing anyway"
          fi
          
          # Check if Makefile was created or already exists
          if [ -f "Makefile" ]; then
            echo "Makefile found. Running make..."
            make || echo "make failed, continuing anyway"
          else
            echo "No Makefile found after configure. Checking for other build systems..."
            # Try to detect if this is a Bazel project
            if [ -f "WORKSPACE" ] || [ -f "BUILD" ] || [ -f "BUILD.bazel" ]; then
              echo "Detected Bazel build system. Skipping make."
              # Optionally run a basic Bazel build if needed
              # bazel build //... --config=opt || echo "bazel build failed, continuing anyway"
            else
              echo "No recognized build system found after configure."
            fi
          fi
        fi
      continue-on-error: true

    - name: Build with Make
      if: steps.check_build.outputs.HAS_MAKEFILE == 'true'
      run: |
        make
      continue-on-error: true

    - name: Collect all dependencies
      run: |
        # Get repository name
        REPO_NAME=$(echo '${{ github.repository }}' | awk -F '/' '{print $2}')
        
        echo "# Dependency Report" > ${REPO_NAME}-dependency-report.md
        echo "Generated on $(date)" >> ${REPO_NAME}-dependency-report.md
        echo "" >> ${REPO_NAME}-dependency-report.md
        
        # Create directory to store detailed dependency information
        mkdir -p dependency_info
        
        echo "## System Dependencies" >> ${REPO_NAME}-dependency-report.md
        echo "Listing installed apt packages:" >> ${REPO_NAME}-dependency-report.md
        echo '```' >> ${REPO_NAME}-dependency-report.md
        dpkg-query -W -f='${binary:Package} ${Version}\n' | sort >> ${REPO_NAME}-dependency-report.md
        echo '```' >> ${REPO_NAME}-dependency-report.md
        
        # Git Submodules Analysis
        echo "" >> ${REPO_NAME}-dependency-report.md
        echo "## Git Submodules" >> ${REPO_NAME}-dependency-report.md
        if [ -f ".gitmodules" ]; then
          echo "### Detected Git Submodules" >> ${REPO_NAME}-dependency-report.md
          echo '```' >> ${REPO_NAME}-dependency-report.md
          cat .gitmodules >> ${REPO_NAME}-dependency-report.md
          echo '```' >> ${REPO_NAME}-dependency-report.md
          
          echo "" >> ${REPO_NAME}-dependency-report.md
          echo "### Submodule Versions (Commit Hashes)" >> ${REPO_NAME}-dependency-report.md
          echo '```' >> ${REPO_NAME}-dependency-report.md
          git submodule status >> ${REPO_NAME}-dependency-report.md 2>/dev/null || echo "Could not get submodule status" >> ${REPO_NAME}-dependency-report.md
          echo '```' >> ${REPO_NAME}-dependency-report.md
          
          # Try to get more detailed information from each submodule
          echo "" >> ${REPO_NAME}-dependency-report.md
          echo "### Detailed Submodule Information" >> ${REPO_NAME}-dependency-report.md
          echo '```' >> ${REPO_NAME}-dependency-report.md
          git submodule foreach 'echo "Submodule: $name"; git log -n 1 --pretty=format:"%h %s %ad" --date=short; echo ""; if [ -f "VERSION" ]; then echo "VERSION file: $(cat VERSION)"; fi; if [ -f "version.txt" ]; then echo "version.txt: $(cat version.txt)"; fi; echo ""' 2>/dev/null || echo "Could not get detailed submodule info" >> ${REPO_NAME}-dependency-report.md
          echo '```' >> ${REPO_NAME}-dependency-report.md
        else
          echo "No .gitmodules file found. Repository does not use git submodules." >> ${REPO_NAME}-dependency-report.md
        fi
        
        # Vendored Dependencies Analysis
        echo "" >> ${REPO_NAME}-dependency-report.md
        echo "## Vendored Dependencies" >> ${REPO_NAME}-dependency-report.md
        
        # Common directories where dependencies are vendored
        echo "### Common Vendored Directories" >> ${REPO_NAME}-dependency-report.md
        echo '```' >> ${REPO_NAME}-dependency-report.md
        # Add LLVM-specific directories to the search patterns
        for DIR in vendor third_party external lib/vendor deps dependencies ext contrib ThirdParty llvm/utils llvm/lib third-party runtimes; do
          if [ -d "$DIR" ]; then
            echo "Found potential vendored directory: $DIR" >> ${REPO_NAME}-dependency-report.md
            echo "Contents:" >> ${REPO_NAME}-dependency-report.md
            ls -la "$DIR" >> ${REPO_NAME}-dependency-report.md
            echo "" >> ${REPO_NAME}-dependency-report.md
            
            # Special handling for LLVM libraries
            if [[ "$DIR" == "llvm/utils" ]] || [[ "$DIR" == "llvm/lib" ]] || [[ "$DIR" == "third-party" ]] || [[ "$DIR" == "runtimes" ]]; then
              echo "LLVM library directory detected: $DIR" >> ${REPO_NAME}-dependency-report.md
              
              # Look for googletest
              if [ -d "$DIR/googletest" ] || [ -d "$DIR/gtest" ]; then
                echo "Found googletest in $DIR" >> ${REPO_NAME}-dependency-report.md
                # Look for version information
                find "$DIR/googletest" "$DIR/gtest" -name "CMakeLists.txt" -o -name "README.md" | while read -r file; do
                  if [ -f "$file" ]; then
                    echo "Version information from $file:" >> ${REPO_NAME}-dependency-report.md
                    grep -i -E "version|release" "$file" >> ${REPO_NAME}-dependency-report.md 2>/dev/null || echo "No version info found" >> ${REPO_NAME}-dependency-report.md
                  fi
                done
              fi
              
              # Look for zlib
              if [ -d "$DIR/zlib" ]; then
                echo "Found zlib in $DIR" >> ${REPO_NAME}-dependency-report.md
                # Look for version information
                if [ -f "$DIR/zlib/zlib.h" ]; then
                  echo "Version information from zlib.h:" >> ${REPO_NAME}-dependency-report.md
                  grep -E '#define.*VERSION|version|ZLIB_VERSION' "$DIR/zlib/zlib.h" >> ${REPO_NAME}-dependency-report.md 2>/dev/null || echo "No version defines found" >> ${REPO_NAME}-dependency-report.md
                fi
              fi
            fi
          fi
        done
        echo '```' >> ${REPO_NAME}-dependency-report.md
        
        # Look for LLVM-specific dependencies
        echo "" >> ${REPO_NAME}-dependency-report.md
        echo "### LLVM-Specific Dependencies" >> ${REPO_NAME}-dependency-report.md
        echo '```' >> ${REPO_NAME}-dependency-report.md
        # Look for common LLVM dependencies
        for DEP in googletest gtest zlib; do
          if [ -d "$DEP" ] || [ -d "lib$DEP" ]; then
            echo "Found $DEP library" >> ${REPO_NAME}-dependency-report.md
            # Try to find version information
            find . -path "*/$DEP/*" -o -path "*/lib$DEP/*" | grep -E 'version\.h|VERSION|version\.txt|README|CHANGELOG|CMakeLists.txt' | while read -r file; do
              if [ -f "$file" ]; then
                echo "Version information from $file:" >> ${REPO_NAME}-dependency-report.md
                if [[ "$file" == *"version.h"* ]]; then
                  grep -E '#define.*VERSION|version|RELEASE' "$file" >> ${REPO_NAME}-dependency-report.md 2>/dev/null || echo "No version defines found" >> ${REPO_NAME}-dependency-report.md
                elif [[ "$file" == *"CMakeLists.txt"* ]]; then
                  grep -i -E "version|project" "$file" >> ${REPO_NAME}-dependency-report.md 2>/dev/null || echo "No version info found" >> ${REPO_NAME}-dependency-report.md
                else
                  head -n 20 "$file" | grep -i -E "version|release" >> ${REPO_NAME}-dependency-report.md 2>/dev/null || echo "No obvious version info in header" >> ${REPO_NAME}-dependency-report.md
                fi
              fi
            done
          fi
        done
        echo '```' >> ${REPO_NAME}-dependency-report.md
        
        # Install and use OSV scanner for detecting versions of vendored code, if available
        echo "" >> ${REPO_NAME}-dependency-report.md
        echo "### OSV Version Detection" >> ${REPO_NAME}-dependency-report.md
        echo '```' >> ${REPO_NAME}-dependency-report.md
        python3 -m pip install --user osv 2>/dev/null || echo "Could not install OSV scanner" >> ${REPO_NAME}-dependency-report.md
        if command -v osv-scanner &> /dev/null; then
          echo "Running OSV scanner to detect vendored package versions..." >> ${REPO_NAME}-dependency-report.md
          osv-scanner scan --recursive . >> ${REPO_NAME}-dependency-report.md 2>/dev/null || echo "OSV scanner failed or found no results" >> ${REPO_NAME}-dependency-report.md
        else
          echo "OSV scanner not available. Could not scan for vendored package versions." >> ${REPO_NAME}-dependency-report.md
        fi
        echo '```' >> ${REPO_NAME}-dependency-report.md
        
        # Look for version information in vendored directories
        echo "" >> ${REPO_NAME}-dependency-report.md
        echo "### Version Information in Vendored Code" >> ${REPO_NAME}-dependency-report.md
        echo '```' >> ${REPO_NAME}-dependency-report.md
        # Search for version files, headers and other common version indicators
        find . -path "*/vendor/*" -o -path "*/third_party/*" -o -path "*/external/*" -o -path "*/ThirdParty/*" -o -path "*/deps/*" | grep -E 'version\.h|VERSION|version\.txt|package\.json|setup\.py|\.gemspec|README|CHANGELOG|LICENSE' | while read -r file; do
          if [ -f "$file" ]; then
            echo "Examining $file for version information:" >> ${REPO_NAME}-dependency-report.md
            # Extract version information using various patterns
            if [[ "$file" == *"version.h"* ]]; then
              grep -E '#define.*VERSION|version|RELEASE' "$file" >> ${REPO_NAME}-dependency-report.md 2>/dev/null || echo "No version defines found" >> ${REPO_NAME}-dependency-report.md
            elif [[ "$file" == *"package.json"* ]]; then
              grep -E '"version"|"name"' "$file" >> ${REPO_NAME}-dependency-report.md 2>/dev/null || echo "No version info found" >> ${REPO_NAME}-dependency-report.md
            elif [[ "$file" == *"setup.py"* ]]; then
              grep -E "version|name" "$file" >> ${REPO_NAME}-dependency-report.md 2>/dev/null || echo "No version info found" >> ${REPO_NAME}-dependency-report.md
            elif [[ "$file" == *".gemspec"* ]]; then
              grep -E "version|name" "$file" >> ${REPO_NAME}-dependency-report.md 2>/dev/null || echo "No version info found" >> ${REPO_NAME}-dependency-report.md
            elif [[ "$file" == *"VERSION"* || "$file" == *"version.txt"* ]]; then
              cat "$file" >> ${REPO_NAME}-dependency-report.md 2>/dev/null || echo "Could not read file" >> ${REPO_NAME}-dependency-report.md
            else
              # For README, LICENSE, etc. just look for version mentions
              head -n 20 "$file" | grep -i -E "version|release" >> ${REPO_NAME}-dependency-report.md 2>/dev/null || echo "No obvious version info in header" >> ${REPO_NAME}-dependency-report.md
            fi
            echo "" >> ${REPO_NAME}-dependency-report.md
          fi
        done
        echo '```' >> ${REPO_NAME}-dependency-report.md
        
        # Use git history on vendored directories to find when they were last updated
        echo "" >> ${REPO_NAME}-dependency-report.md
        echo "### Git History for Vendored Directories" >> ${REPO_NAME}-dependency-report.md
        echo '```' >> ${REPO_NAME}-dependency-report.md
        for DIR in vendor third_party external lib/vendor deps dependencies ext contrib ThirdParty; do
          if [ -d "$DIR" ]; then
            echo "Git history for $DIR:" >> ${REPO_NAME}-dependency-report.md
            git log -n 3 --pretty=format:"%h %s %ad" --date=short -- "$DIR" >> ${REPO_NAME}-dependency-report.md 2>/dev/null || echo "Could not get git history" >> ${REPO_NAME}-dependency-report.md
            echo "" >> ${REPO_NAME}-dependency-report.md
            
            # Check commits for specific directories inside vendored dirs
            SUBDIRS=$(find "$DIR" -maxdepth 1 -type d | tail -n +2)
            for SUBDIR in $SUBDIRS; do
              if [ -d "$SUBDIR" ]; then
                echo "Last commit for $SUBDIR:" >> ${REPO_NAME}-dependency-report.md
                git log -n 1 --pretty=format:"%h %s %ad" --date=short -- "$SUBDIR" >> ${REPO_NAME}-dependency-report.md 2>/dev/null || echo "Could not get git history" >> ${REPO_NAME}-dependency-report.md
                echo "" >> ${REPO_NAME}-dependency-report.md
              fi
            done
          fi
        done
        echo '```' >> ${REPO_NAME}-dependency-report.md
        
        # CMake Dependencies section after the vendored dependencies analysis
        echo "" >> ${REPO_NAME}-dependency-report.md
        echo "## CMake Dependencies" >> ${REPO_NAME}-dependency-report.md
        # Find all CMakeLists.txt files in the project, not just in the root
        CMAKE_FILES=$(find . -name "CMakeLists.txt" -not -path "*/build/*" -not -path "*/\.*")
        if [ ! -z "$CMAKE_FILES" ]; then
          echo "### Direct CMake Dependencies" >> ${REPO_NAME}-dependency-report.md
          echo '```' >> ${REPO_NAME}-dependency-report.md
          # Extract and document all find_package and pkg_check_modules calls more thoroughly
          for CMAKE_FILE in $CMAKE_FILES; do
            echo "File: $CMAKE_FILE" >> ${REPO_NAME}-dependency-report.md
            {
              grep -n "find_package" "$CMAKE_FILE" || echo "No find_package found"
              grep -n "pkg_check_modules" "$CMAKE_FILE" || echo "No pkg_check_modules found"
            } >> ${REPO_NAME}-dependency-report.md
            echo "" >> ${REPO_NAME}-dependency-report.md
          done
          echo '```' >> ${REPO_NAME}-dependency-report.md
          
          # Try to get actual versions from CMake cache if build has run
          if [ -f "build/CMakeCache.txt" ]; then
            echo "" >> ${REPO_NAME}-dependency-report.md
            echo "### CMake Cache - Dependency Versions" >> ${REPO_NAME}-dependency-report.md
            echo '```' >> ${REPO_NAME}-dependency-report.md
            grep -E "_VERSION|_FOUND" build/CMakeCache.txt | sort >> ${REPO_NAME}-dependency-report.md
            echo '```' >> ${REPO_NAME}-dependency-report.md
            
            # Save detailed cmake info
            cp build/CMakeCache.txt dependency_info/
            [ -f build/compile_commands.json ] && cp build/compile_commands.json dependency_info/
          fi
        else
          echo "No CMakeLists.txt files found in the project." >> ${REPO_NAME}-dependency-report.md
        fi
        
        # Conan dependencies
        if [ -f "conanfile.txt" ] || [ -f "conanfile.py" ]; then
          echo "" >> ${REPO_NAME}-dependency-report.md
          echo "## Conan Dependencies" >> ${REPO_NAME}-dependency-report.md
          
          echo "### Conan Direct Dependencies" >> ${REPO_NAME}-dependency-report.md
          echo '```' >> ${REPO_NAME}-dependency-report.md
          if [ -f "conanfile.txt" ]; then
            cat conanfile.txt >> ${REPO_NAME}-dependency-report.md
          else
            cat conanfile.py >> ${REPO_NAME}-dependency-report.md
          fi
          echo '```' >> ${REPO_NAME}-dependency-report.md
          
          echo "" >> ${REPO_NAME}-dependency-report.md
          echo "### Conan Dependency Graph" >> ${REPO_NAME}-dependency-report.md
          echo '```' >> ${REPO_NAME}-dependency-report.md
          # Try to run conan info but don't fail if it doesn't work
          (cd build && conan info .. 2>/dev/null) >> ${REPO_NAME}-dependency-report.md || echo "Could not generate Conan info" >> ${REPO_NAME}-dependency-report.md
          echo '```' >> ${REPO_NAME}-dependency-report.md
          
          # Get Conan lock file if available
          [ -f "build/conanbuildinfo.txt" ] && cp build/conanbuildinfo.txt dependency_info/
          [ -f "build/conaninfo.txt" ] && cp build/conaninfo.txt dependency_info/
        fi
        
        # vcpkg dependencies
        if [ -f "vcpkg.json" ]; then
          echo "" >> ${REPO_NAME}-dependency-report.md
          echo "## vcpkg Dependencies" >> ${REPO_NAME}-dependency-report.md
          echo "### vcpkg Direct Dependencies" >> ${REPO_NAME}-dependency-report.md
          echo '```json' >> ${REPO_NAME}-dependency-report.md
          cat vcpkg.json >> ${REPO_NAME}-dependency-report.md
          echo '```' >> ${REPO_NAME}-dependency-report.md
          
          # If using vcpkg with CMake, try to extract more info
          if [ -d "build/vcpkg_installed" ]; then
            echo "" >> ${REPO_NAME}-dependency-report.md
            echo "### Installed vcpkg Packages" >> ${REPO_NAME}-dependency-report.md
            echo '```' >> ${REPO_NAME}-dependency-report.md
            find build/vcpkg_installed -name "CONTROL" -o -name "vcpkg_abi_info.txt" | xargs cat 2>/dev/null >> ${REPO_NAME}-dependency-report.md || echo "No detailed vcpkg info found" >> ${REPO_NAME}-dependency-report.md
            echo '```' >> ${REPO_NAME}-dependency-report.md
          fi
        fi
        
        # Look for typical C/C++ dependency patterns in source code
        echo "" >> ${REPO_NAME}-dependency-report.md
        echo "## Source Code Analysis" >> ${REPO_NAME}-dependency-report.md
        echo "### Include Statements" >> ${REPO_NAME}-dependency-report.md
        echo '```' >> ${REPO_NAME}-dependency-report.md
        find . -type f -name "*.c" -o -name "*.cpp" -o -name "*.h" -o -name "*.hpp" | xargs grep -l "#include" 2>/dev/null | head -n 50 | xargs grep "#include" 2>/dev/null | sort | uniq -c | sort -nr >> ${REPO_NAME}-dependency-report.md 2>/dev/null || echo "No C/C++ includes found" >> ${REPO_NAME}-dependency-report.md
        echo '```' >> ${REPO_NAME}-dependency-report.md
        
        # Look at shared library dependencies in compiled binaries
        echo "" >> ${REPO_NAME}-dependency-report.md
        echo "## Binary Analysis" >> ${REPO_NAME}-dependency-report.md
        echo "### Shared Library Dependencies" >> ${REPO_NAME}-dependency-report.md
        echo '```' >> ${REPO_NAME}-dependency-report.md
        find . -type f -executable -not -path "*/\.*" | head -n 20 | xargs -I{} bash -c "echo 'File: {}'; ldd {} 2>/dev/null || echo 'Not a dynamic executable'" >> ${REPO_NAME}-dependency-report.md 2>/dev/null || echo "No binaries found or ldd not available" >> ${REPO_NAME}-dependency-report.md
        echo '```' >> ${REPO_NAME}-dependency-report.md
        
        # Create a compressed archive of all dependency information
        tar -czf dependency_info.tar.gz dependency_info ${REPO_NAME}-dependency-report.md
        
        echo "Dependency report generated at ${REPO_NAME}-dependency-report.md"
      continue-on-error: true
        
    - name: Generate Conanfile
      run: |
        # Get repository name
        REPO_NAME=$(echo '${{ github.repository }}' | awk -F '/' '{print $2}')
        
        # Create conanfile.txt
        echo "[requires]" > ${REPO_NAME}-conanfile.txt
        
        # Extract system package dependencies
        echo "# System Package Dependencies" >> ${REPO_NAME}-conanfile.txt
        dpkg-query -W -f='${binary:Package}\n' | grep -E '^lib.*-dev$' | sed 's/-dev$//' | while read -r pkg; do
          case $pkg in
            libboost*)
              VERSION=$(dpkg-query -W -f='${Version}' libboost-dev | cut -d. -f1-2)
              echo "boost/${VERSION}" >> ${REPO_NAME}-conanfile.txt
              ;;
            libzlib*)
              VERSION=$(dpkg-query -W -f='${Version}' zlib1g-dev | cut -d- -f1)
              echo "zlib/${VERSION}" >> ${REPO_NAME}-conanfile.txt
              ;;
            libssl*)
              VERSION=$(dpkg-query -W -f='${Version}' libssl-dev | cut -d- -f1)
              echo "openssl/${VERSION}" >> ${REPO_NAME}-conanfile.txt
              ;;
            libcurl*)
              VERSION=$(dpkg-query -W -f='${Version}' libcurl4-openssl-dev | cut -d- -f1)
              echo "libcurl/${VERSION}" >> ${REPO_NAME}-conanfile.txt
              ;;
            libmysqlclient*)
              VERSION=$(dpkg-query -W -f='${Version}' libmysqlclient-dev | cut -d- -f1)
              echo "mysqlclient/${VERSION}" >> ${REPO_NAME}-conanfile.txt
              ;;
            libpq*)
              VERSION=$(dpkg-query -W -f='${Version}' libpq-dev | cut -d- -f1)
              echo "pq/${VERSION}" >> ${REPO_NAME}-conanfile.txt
              ;;
            *)
              # Try to map other packages
              CONAN_PKG=$(echo $pkg | sed 's/^lib//')
              VERSION=$(dpkg-query -W -f='${Version}' ${pkg}-dev 2>/dev/null | cut -d- -f1)
              if [ ! -z "$VERSION" ]; then
                echo "${CONAN_PKG}/${VERSION}" >> ${REPO_NAME}-conanfile.txt
              fi
              ;;
          esac
        done
        
        # Extract CMake dependencies
        if [ -f "build/CMakeCache.txt" ]; then
          echo "" >> ${REPO_NAME}-conanfile.txt
          echo "# CMake Dependencies" >> ${REPO_NAME}-conanfile.txt
          grep -E "_VERSION|_FOUND" build/CMakeCache.txt | grep -v "NOTFOUND" | while read -r line; do
            PKG=$(echo $line | cut -d: -f1 | sed 's/_VERSION//' | sed 's/_FOUND//')
            VERSION=$(echo $line | cut -d= -f2)
            if [[ $VERSION != "INTERNAL" ]] && [[ $VERSION != "1" ]]; then
              echo "${PKG}/${VERSION}" >> ${REPO_NAME}-conanfile.txt
            fi
          done
        fi
        
        # Extract vendored dependencies from the report
        echo "" >> ${REPO_NAME}-conanfile.txt
        echo "# Vendored Dependencies" >> ${REPO_NAME}-conanfile.txt
        
        # First check LLVM-specific directories and subprojects
        for DIR in llvm/utils llvm/lib third-party runtimes clang/tools/extra clang lld lldb; do
          if [ -d "$DIR" ]; then
            # Look for googletest
            if [ -d "$DIR/googletest" ] || [ -d "$DIR/gtest" ]; then
              # Try OSV determineversion API first
              echo "Attempting to determine version using OSV API for googletest..."
              OSV_VERSION=$(find "$DIR/googletest" "$DIR/gtest" -type f \( -name "*.c" -o -name "*.cc" -o -name "*.h" -o -name "*.hh" -o -name "*.cpp" -o -name "*.hpp" \) -exec md5sum {} \; | sort | cut -d' ' -f1 | tr '\n' ' ' | xargs -I{} curl -s -X POST "https://api.osv.dev/v1experimental/determineversion" \
                -H "Content-Type: application/json" \
                -d "{\"name\":\"googletest\",\"file_hashes\":[{\"hash\":\"{}\",\"file_path\":\"\"}]}" | jq -r '.matches[0].repo_info.version // empty')
              
              if [ ! -z "$OSV_VERSION" ]; then
                echo "Found version using OSV API: $OSV_VERSION"
                VERSION=$OSV_VERSION
                VERSION_SOURCE="OSV API"
              else
                # Fallback to traditional version detection
                VERSION=$(find "$DIR/googletest" "$DIR/gtest" -type f \( -name "CMakeLists.txt" -o -name "README.md" -o -name "version.txt" -o -name "VERSION" \) -exec grep -E "version|release|VERSION" {} \; 2>/dev/null | grep -oE '[0-9]+\.[0-9]+(\.[0-9]+)?' | head -n 1)
                if [ ! -z "$VERSION" ]; then
                  VERSION_SOURCE="File-based detection (CMakeLists.txt/README/VERSION)"
                else
                  VERSION="1.12.1"  # Default version if not found
                  VERSION_SOURCE="Default version"
                fi
              fi
              echo "gtest/${VERSION} # Version determined via ${VERSION_SOURCE}" >> ${REPO_NAME}-conanfile.txt
            fi
            
            # Look for zlib
            if [ -d "$DIR/zlib" ]; then
              # Try OSV determineversion API first
              echo "Attempting to determine version using OSV API for zlib..."
              OSV_VERSION=$(find "$DIR/zlib" -type f \( -name "*.c" -o -name "*.cc" -o -name "*.h" -o -name "*.hh" -o -name "*.cpp" -o -name "*.hpp" \) -exec md5sum {} \; | sort | cut -d' ' -f1 | tr '\n' ' ' | xargs -I{} curl -s -X POST "https://api.osv.dev/v1experimental/determineversion" \
                -H "Content-Type: application/json" \
                -d "{\"name\":\"zlib\",\"file_hashes\":[{\"hash\":\"{}\",\"file_path\":\"\"}]}" | jq -r '.matches[0].repo_info.version // empty')
              
              if [ ! -z "$OSV_VERSION" ]; then
                echo "Found version using OSV API: $OSV_VERSION"
                VERSION=$OSV_VERSION
                VERSION_SOURCE="OSV API"
              else
                # Fallback to traditional version detection
                VERSION=$(find "$DIR/zlib" -type f \( -name "zlib.h" -o -name "CMakeLists.txt" -o -name "README" -o -name "version.txt" -o -name "VERSION" \) -exec grep -E "#define.*VERSION|ZLIB_VERSION|version|release" {} \; 2>/dev/null | grep -oE '[0-9]+\.[0-9]+(\.[0-9]+)?' | head -n 1)
                if [ ! -z "$VERSION" ]; then
                  VERSION_SOURCE="File-based detection (zlib.h/CMakeLists.txt/VERSION)"
                else
                  VERSION="1.2.13"  # Default version if not found
                  VERSION_SOURCE="Default version"
                fi
              fi
              echo "zlib/${VERSION} # Version determined via ${VERSION_SOURCE}" >> ${REPO_NAME}-conanfile.txt
            fi
            
            # Look for other common LLVM dependencies
            for DEP in libxml2 libedit libffi; do
              if [ -d "$DIR/$DEP" ]; then
                # Try OSV determineversion API first
                echo "Attempting to determine version using OSV API for $DEP..."
                OSV_VERSION=$(find "$DIR/$DEP" -type f \( -name "*.c" -o -name "*.cc" -o -name "*.h" -o -name "*.hh" -o -name "*.cpp" -o -name "*.hpp" \) -exec md5sum {} \; | sort | cut -d' ' -f1 | tr '\n' ' ' | xargs -I{} curl -s -X POST "https://api.osv.dev/v1experimental/determineversion" \
                  -H "Content-Type: application/json" \
                  -d "{\"name\":\"$DEP\",\"file_hashes\":[{\"hash\":\"{}\",\"file_path\":\"\"}]}" | jq -r '.matches[0].repo_info.version // empty')
                
                if [ ! -z "$OSV_VERSION" ]; then
                  echo "Found version using OSV API: $OSV_VERSION"
                  VERSION=$OSV_VERSION
                  VERSION_SOURCE="OSV API"
                else
                  # Fallback to traditional version detection
                  VERSION=$(find "$DIR/$DEP" -type f \( -name "*.h" -o -name "CMakeLists.txt" -o -name "configure.ac" -o -name "README" -o -name "version.txt" -o -name "VERSION" \) -exec grep -E "version|VERSION|AC_INIT|release" {} \; 2>/dev/null | grep -oE '[0-9]+\.[0-9]+(\.[0-9]+)?' | head -n 1)
                  if [ ! -z "$VERSION" ]; then
                    VERSION_SOURCE="File-based detection (headers/CMakeLists.txt/VERSION)"
                  else
                    case $DEP in
                      "libxml2")
                        VERSION="2.11.5"
                        VERSION_SOURCE="Default version"
                        ;;
                      "libedit")
                        VERSION="20230828"
                        VERSION_SOURCE="Default version"
                        ;;
                      "libffi")
                        VERSION="3.4.4"
                        VERSION_SOURCE="Default version"
                        ;;
                    esac
                  fi
                fi
                echo "${DEP}/${VERSION} # Version determined via ${VERSION_SOURCE}" >> ${REPO_NAME}-conanfile.txt
              fi
            done

            # Look for other potential dependencies in common directories
            for SUBDIR in $(find "$DIR" -maxdepth 1 -type d | grep -v "^$DIR$"); do
              DEP_NAME=$(basename "$SUBDIR")
              # Skip common non-dependency directories and LLVM internal components
              if [[ "$DEP_NAME" != "CMakeFiles" && \
                    "$DEP_NAME" != "include" && \
                    "$DEP_NAME" != "src" && \
                    "$DEP_NAME" != "test" && \
                    "$DEP_NAME" != "tests" && \
                    "$DEP_NAME" != "utils" && \
                    "$DEP_NAME" != "lib" && \
                    "$DEP_NAME" != "tools" && \
                    "$DEP_NAME" != "docs" && \
                    "$DEP_NAME" != "examples" && \
                    "$DEP_NAME" != "bindings" && \
                    "$DEP_NAME" != "unittests" && \
                    "$DEP_NAME" != "scripts" && \
                    "$DEP_NAME" != "packages" && \
                    "$DEP_NAME" != "resources" && \
                    "$DEP_NAME" != "source" && \
                    "$DEP_NAME" != "Common" && \
                    "$DEP_NAME" != "COFF" && \
                    "$DEP_NAME" != "ELF" && \
                    "$DEP_NAME" != "wasm" && \
                    "$DEP_NAME" != "MinGW" && \
                    "$DEP_NAME" != "MachO" && \
                    "$DEP_NAME" != "Target" && \
                    "$DEP_NAME" != "CodeGen" && \
                    "$DEP_NAME" != "IR" && \
                    "$DEP_NAME" != "Support" && \
                    "$DEP_NAME" != "Analysis" && \
                    "$DEP_NAME" != "Object" && \
                    "$DEP_NAME" != "ExecutionEngine" && \
                    "$DEP_NAME" != "ProfileData" && \
                    "$DEP_NAME" != "DebugInfo" && \
                    "$DEP_NAME" != "Bitcode" && \
                    "$DEP_NAME" != "Remarks" && \
                    "$DEP_NAME" != "TargetParser" && \
                    "$DEP_NAME" != "ToolDrivers" && \
                    "$DEP_NAME" != "Bitstream" && \
                    "$DEP_NAME" != "TableGen" && \
                    "$DEP_NAME" != "InterfaceStub" && \
                    "$DEP_NAME" != "WindowsDriver" && \
                    "$DEP_NAME" != "Debuginfod" && \
                    "$DEP_NAME" != "Passes" && \
                    "$DEP_NAME" != "Transforms" && \
                    "$DEP_NAME" != "MC" && \
                    "$DEP_NAME" != "Telemetry" && \
                    "$DEP_NAME" != "Fuzzer" && \
                    "$DEP_NAME" != "TextAPI" && \
                    "$DEP_NAME" != "LTO" && \
                    "$DEP_NAME" != "git" && \
                    "$DEP_NAME" != "gn" && \
                    "$DEP_NAME" != "vim" && \
                    "$DEP_NAME" != "yaml-bench" && \
                    "$DEP_NAME" != "vscode" && \
                    "$DEP_NAME" != "FileCheck" && \
                    "$DEP_NAME" != "crosstool" && \
                    "$DEP_NAME" != "UnicodeData" && \
                    "$DEP_NAME" != "filecheck_lint" && \
                    "$DEP_NAME" != "sanitizers" && \
                    "$DEP_NAME" != "valgrind" && \
                    "$DEP_NAME" != "rsp_bisect_test" && \
                    "$DEP_NAME" != "jedit" && \
                    "$DEP_NAME" != "emacs" && \
                    "$DEP_NAME" != "kate" && \
                    "$DEP_NAME" != "llvm-lit" && \
                    "$DEP_NAME" != "lint" && \
                    "$DEP_NAME" != "spirv-sim" && \
                    "$DEP_NAME" != "LLVMVisualizers" && \
                    "$DEP_NAME" != "llvm-locstats" && \
                    "$DEP_NAME" != "Target" && \
                    "$DEP_NAME" != "gdb-scripts" && \
                    "$DEP_NAME" != "fpcmp" && \
                    "$DEP_NAME" != "Misc" && \
                    "$DEP_NAME" != "UpdateTestChecks" && \
                    "$DEP_NAME" != "reduce_pipeline_test" && \
                    "$DEP_NAME" != "docker" && \
                    "$DEP_NAME" != "PerfectShuffle" && \
                    "$DEP_NAME" != "TableGen" && \
                    "$DEP_NAME" != "KillTheDoctor" && \
                    "$DEP_NAME" != "lit" && \
                    "$DEP_NAME" != "mlgo-utils" && \
                    "$DEP_NAME" != "bugpoint" && \
                    "$DEP_NAME" != "count" && \
                    "$DEP_NAME" != "testgen" && \
                    "$DEP_NAME" != "release" && \
                    "$DEP_NAME" != "not" && \
                    "$DEP_NAME" != "textmate" && \
                    "$DEP_NAME" != "Reviewing" ]]; then
                # Try OSV determineversion API first
                echo "Attempting to determine version using OSV API for $DEP_NAME..."
                OSV_VERSION=$(find "$SUBDIR" -type f \( -name "*.c" -o -name "*.cc" -o -name "*.h" -o -name "*.hh" -o -name "*.cpp" -o -name "*.hpp" \) -exec md5sum {} \; | sort | cut -d' ' -f1 | tr '\n' ' ' | xargs -I{} curl -s -X POST "https://api.osv.dev/v1experimental/determineversion" \
                  -H "Content-Type: application/json" \
                  -d "{\"name\":\"$DEP_NAME\",\"file_hashes\":[{\"hash\":\"{}\",\"file_path\":\"\"}]}" | jq -r '.matches[0].repo_info.version // empty')
                
                if [ ! -z "$OSV_VERSION" ]; then
                  echo "Found version using OSV API: $OSV_VERSION"
                  VERSION=$OSV_VERSION
                  VERSION_SOURCE="OSV API"
                else
                  # Fallback to traditional version detection
                  VERSION=$(find "$SUBDIR" -type f \( -name "*.h" -o -name "CMakeLists.txt" -o -name "configure.ac" -o -name "VERSION" -o -name "version.txt" -o -name "README" -o -name "CHANGELOG" \) -exec grep -E "version|VERSION|AC_INIT|release" {} \; 2>/dev/null | grep -oE '[0-9]+\.[0-9]+(\.[0-9]+)?' | head -n 1)
                  if [ ! -z "$VERSION" ]; then
                    VERSION_SOURCE="File-based detection (headers/CMakeLists.txt/VERSION)"
                  else
                    # Try to get version from git history
                    VERSION=$(git log -n 1 --pretty=format:"%h" -- "$SUBDIR" 2>/dev/null)
                    if [ ! -z "$VERSION" ]; then
                      VERSION_SOURCE="Git commit hash"
                    else
                      VERSION="1.0.0"
                      VERSION_SOURCE="Default version"
                    fi
                  fi
                fi
                echo "${DEP_NAME}/${VERSION} # Version determined via ${VERSION_SOURCE}" >> ${REPO_NAME}-conanfile.txt
              fi
            done
          fi
        done
        
        # Then look for library mentions in the report
        grep -A 1 "Found vendored library" ${REPO_NAME}-dependency-report.md | while read -r line; do
          if [[ $line == *"Found vendored library"* ]]; then
            LIB_NAME=$(echo $line | sed 's/Found vendored library: //')
            # Try to find version in the next few lines
            VERSION=$(grep -A 5 "$line" ${REPO_NAME}-dependency-report.md | grep -E "version|VERSION" | head -n 1 | grep -oE '[0-9]+\.[0-9]+(\.[0-9]+)?')
            if [ ! -z "$VERSION" ]; then
              VERSION_SOURCE="Dependency report analysis"
              # Map library names to Conan package names
              case $LIB_NAME in
                "zlib")
                  echo "zlib/${VERSION} # Version determined via ${VERSION_SOURCE}" >> ${REPO_NAME}-conanfile.txt
                  ;;
                "googletest"|"gtest")
                  echo "gtest/${VERSION} # Version determined via ${VERSION_SOURCE}" >> ${REPO_NAME}-conanfile.txt
                  ;;
                "libxml2")
                  echo "libxml2/${VERSION} # Version determined via ${VERSION_SOURCE}" >> ${REPO_NAME}-conanfile.txt
                  ;;
                "libedit")
                  echo "libedit/${VERSION} # Version determined via ${VERSION_SOURCE}" >> ${REPO_NAME}-conanfile.txt
                  ;;
                "libffi")
                  echo "libffi/${VERSION} # Version determined via ${VERSION_SOURCE}" >> ${REPO_NAME}-conanfile.txt
                  ;;
                *)
                  echo "${LIB_NAME}/${VERSION} # Version determined via ${VERSION_SOURCE}" >> ${REPO_NAME}-conanfile.txt
                  ;;
              esac
            else
              VERSION_SOURCE="Default version"
              # Use default versions for known libraries
              case $LIB_NAME in
                "zlib")
                  echo "zlib/1.2.13 # Version determined via ${VERSION_SOURCE}" >> ${REPO_NAME}-conanfile.txt
                  ;;
                "googletest"|"gtest")
                  echo "gtest/1.12.1 # Version determined via ${VERSION_SOURCE}" >> ${REPO_NAME}-conanfile.txt
                  ;;
                "libxml2")
                  echo "libxml2/2.11.5 # Version determined via ${VERSION_SOURCE}" >> ${REPO_NAME}-conanfile.txt
                  ;;
                "libedit")
                  echo "libedit/20230828 # Version determined via ${VERSION_SOURCE}" >> ${REPO_NAME}-conanfile.txt
                  ;;
                "libffi")
                  echo "libffi/3.4.4 # Version determined via ${VERSION_SOURCE}" >> ${REPO_NAME}-conanfile.txt
                  ;;
                *)
                  echo "${LIB_NAME}/1.0.0 # Version determined via ${VERSION_SOURCE}" >> ${REPO_NAME}-conanfile.txt
                  ;;
              esac
            fi
          fi
        done
        
        # Extract Conan dependencies if they exist
        if [ -f "conanfile.txt" ]; then
          echo "" >> ${REPO_NAME}-conanfile.txt
          echo "# Original Conan Dependencies" >> ${REPO_NAME}-conanfile.txt
          grep -v "^#" conanfile.txt | grep -v "^$" | while read -r line; do
            if [[ $line == *"#"* ]]; then
              echo "$line" >> ${REPO_NAME}-conanfile.txt
            else
              echo "$line # Version from original conanfile.txt" >> ${REPO_NAME}-conanfile.txt
            fi
          done
        fi
        
        # Add build requirements with version source
        echo "" >> ${REPO_NAME}-conanfile.txt
        echo "[build_requires]" >> ${REPO_NAME}-conanfile.txt
        echo "cmake/3.27.1 # Fixed version for build system" >> ${REPO_NAME}-conanfile.txt
        echo "ninja/1.11.1 # Fixed version for build system" >> ${REPO_NAME}-conanfile.txt
        
        # Add generator
        echo "" >> ${REPO_NAME}-conanfile.txt
        echo "[generators]" >> ${REPO_NAME}-conanfile.txt
        echo "CMakeDeps" >> ${REPO_NAME}-conanfile.txt
        echo "CMakeToolchain" >> ${REPO_NAME}-conanfile.txt
        
        echo "Generated ${REPO_NAME}-conanfile.txt"
      continue-on-error: true
        
    - name: Get repository name
      id: repo-name
      run: echo "REPO_NAME=$(echo '${{ github.repository }}' | awk -F '/' '{print $2}')" >> $GITHUB_OUTPUT

    - name: Download workflow log
      run: |
        # Get the current workflow run ID
        RUN_ID=${{ github.run_id }}
        # Get the repository name
        REPO_NAME=${{ steps.repo-name.outputs.REPO_NAME }}
        # Download the workflow log using GitHub API
        curl -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
             -H "Accept: application/vnd.github.v3+json" \
             "https://api.github.com/repos/${{ github.repository }}/actions/runs/$RUN_ID/logs" \
             -o "${REPO_NAME}-gha.log" || echo "Could not download workflow log"

    - name: Upload dependency report
      uses: actions/upload-artifact@v4
      with:
        name: ${{ steps.repo-name.outputs.REPO_NAME }}-dependency-report
        path: |
          ${{ steps.repo-name.outputs.REPO_NAME }}-dependency-report.md
          dependency_info.tar.gz
          ${{ steps.repo-name.outputs.REPO_NAME }}-conanfile.txt
          ${{ steps.repo-name.outputs.REPO_NAME }}-gha.log
